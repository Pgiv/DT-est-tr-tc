--- 
title: "Estimation en temps réel de la tendance-cycle : apport de l’utilisation des filtres asymétriques dans la détection des points de retournement"
author: "Alain Quartier-la-Tente"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: article
link-citations: yes
description: "DT XXX"
themeoptions: "coding=utf8,language=french"
classoption: 'a4paper,french'
lang: "fr"
fontsize: 12pt
bibliography: [biblio.bib]
biblio-style: authoryear
babel-lang: french
urlcolor: blue
geometry: hmargin = 25mm, vmargin = 25mm
always_allow_html: true
---



<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
library(kableExtra)
# knitr::knit_hooks$restore() # Pour les réinitialiser

is_html <- knitr::is_html_output()
is_latex <- knitr::is_latex_output()

fig.ext <- ifelse(is_latex,"pdf",ifelse(is_html,"svg", "jpg"))
fig.ext_cube <- ifelse(is_latex,"jpg","jpg")
dev <- ifelse(is_latex,"pdf","svg")
# dev2 <- knitr::opts_chunk$get("dev")
fig.path <- ifelse(is_latex,"pdf",ifelse(is_html,"html", "autres"))
knitr::opts_chunk$set(echo = FALSE,
                      fig.path = sprintf("img/bookdown/%s/", fig.path),
                      fig.ext = fig.ext,
                      dev = dev, dpi = 76,
                      cache = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      fig.align = 'center',
                      fig.pos = "",
                      out.extra = NULL)
height_cube <- 1.7



# Fontawesome
htmltools::tagList(rmarkdown::html_dependency_font_awesome())

if(is_html){
    fa_arrow_circle_right <- '<i class="fas fa-arrow-circle-right"></i>'
    fa_r_project <- '<i class="fab fa-r-project"></i>'
}else {
    if(is_latex){
        fa_arrow_circle_right <- "\\faIcon{arrow-circle-right}"
        fa_r_project <- "\\faIcon{r-project}"
    }else {
        fa_arrow_circle_right <- "->"
        fa_r_project <- 'R'
    }
}

################################
########## KNITR ###############
################################
library(htmltools)
markdown_latex <- function(text, to = "latex"){
    res <- sapply(text, function(x){
        dir = tempdir()
        infile <- tempfile(fileext=".md", tmpdir = dir)
        # writeLines(x, infile)
        writeLines(enc2utf8(x), infile,
                   useBytes=TRUE)
        file.copy("biblio.bib",file.path(dir,"biblio.bib"))
        outfile <- tempfile(fileext=".tex", tmpdir = dir)
        rmarkdown::pandoc_convert(infile,
                                  to = to,
                                  from = "markdown",
                                  citeproc = FALSE,
                                  options = c("--bibliography=biblio.bib",
                                              "--biblatex"
                                              ),
                                  output = outfile,
                                  wd = dir)
        paste(readLines(outfile, encoding="UTF-8"), collapse = " ")
    })
    names(res) <- NULL
    res
}
converttext <- ifelse(is_latex,markdown_latex, \(x) x)
latex_emph <- function(entete = "Note", x, sep = "\n\n"){
    txt <- paste(sprintf("\\emph{%s}", x), collapse = sep)
    if(length(x)>1){
        entete <- paste0(entete,"s")
    }
    sprintf("\n\\emph{%s} : %s", entete, txt)
}
md_framed <- function(x, options){
    if (!is_latex || is.null(options$mdframed) || !options$mdframed || 
        is.null(options$fig.cap))
        return (x)
    # cap <- options$fig.cap
    # label <- fig$label
    # \label{fig:filtersdafcoefs}
    # \includegraphics[width=3cm,height=3cm]{example-image-a}
    #     \captionof{figure}{exampleimg}
    x <- gsub("\\\\begin\\{figure\\}(\\[!?\\w*\\])?",
              "", x)
    x <- gsub("\\caption","\\captiontmp", x, fixed = TRUE)
    # x <- gsub("^(\\n)*", "", x)
    x <- gsub("\n\n{\\centering",
              "\\begin{center}", x, fixed = TRUE)
    x <- sub("} \n\n}","}", x, fixed = TRUE)
    x <- gsub("\\end{figure}",
              "\\end{center}", x, fixed = TRUE)
    x
}

add_fig_opt_html <- function(x, options, nom_opt){
    nom_opt_complet <- sprintf("fig.%s", tolower(nom_opt))
    opt <- options[[nom_opt_complet]]
    if(!is.null(opt)){
        first_txt <- tags$p(opt[1], id = nom_opt, class = "title caption")
        all_txt <- c(list(first_txt),
                     lapply(opt[-1], tags$p, class = "caption"))
        txt <- withTags(
            div(class = "caption", id = nom_opt,
                tagList(all_txt)
            )
        )
        x <- paste(x,
                   as.character(txt),
                   sep = "\n")
    }
    x
}

add_fig_opt_latex <- function(x, options, nom_opt, 
                              prefix = nom_opt,
                              sep_multi = "---", sep_fichier = "\n\n"){
    if(is.null(prefix)){
        prefix <- nom_opt
    }
    if(is.null(sep_multi)){
        sep_multi <- "---"
    }
    if(is.null(sep_fichier)){
        sep_fichier <- "\n\n"
    }
    nom_opt_complet <- sprintf("fig.%s", tolower(nom_opt))
    opt <- options[[nom_opt_complet]]
    if(!is.null(opt)){
        x <- paste(x,
                   latex_emph(prefix,
                              markdown_latex(opt),
                              sep = sep_multi),
                   sep = sep_fichier)
    }
    x
}
cite_ref_latex <- function(x){
    split <- strsplit(x, " ")
    sapply(split, function(phrase){
        id_ref <- grep("@", phrase)
        for(i in id_ref){
            x <- phrase[i]
            suffix = gsub("^@\\w*","",x)
            toremoved <- paste0("@",suffix)
            nomref <- x
            for(i_c in seq_len(nchar(toremoved))){
                nomref <- gsub(substr(toremoved,i_c,i_c),"",
                               nomref, fixed = TRUE) 
            }
            phrase[i] <- sprintf("\\textcite{%s}%s",nomref, suffix)
        }
        paste(phrase, collapse = " ")
    })
}
add_footnote_latex <- function(x, options, envir = "figure", remove_envir = TRUE,
                               stop_centering = FALSE){
    
    fin_envir <- sprintf("\\end{%s}", envir)
    if(length(grep(fin_envir, x, fixed = TRUE)) == 0){
        return(x)
    }
    
    params <- list(Source = list(),
                   Champ = list(),
                   Note = list(sep_multi = "\n\n"),
                   Lecture = list(prefix = "Note de lecture"))
    ajouts <- "\\footnotesize"
    for (opt in names(params)){
        ajouts <- add_fig_opt_latex(ajouts, options, opt,
                                    prefix = params[[opt]]$prefix,
                                    sep_multi = params[[opt]]$sep_multi,
                                    sep_fichier = params[[opt]]$sep_fichier)
    }
    if(stop_centering){
        x <- sub("\\\\centering", "{\n\\\\centering", x)
        x <- paste0(x, "}\n")
    }
    x <- paste0(x, ajouts, "\n\\normalsize")
    if(remove_envir){
        x <- sub(fin_envir, "", x, fixed = TRUE)
        
        x <- paste0(x, fin_envir)  
    }
    x  
}

add_footnote_html <- function(x, options){
    for (opt in c("source", "champ", "note", "lecture")){
        x <- add_fig_opt_html(x, options, opt)
    }
    x
}
add_footnote_perso <- function(x, options, envir = "figure", remove_envir = TRUE,
                               stop_centering = FALSE){
    if(is_latex){
        res <-  add_footnote_latex(x, options, envir = envir,
                                   remove_envir = remove_envir,
                                   stop_centering = stop_centering)
        
    }else if(is_html){
        res <-  add_footnote_html(x, options)
    }else{
        res <-  x
    }
    res
}
add_footnote_kable <- function(x, options = knitr::opts_current$get(),
                               stop_centering = FALSE){
    envir = remove_envir = NULL
    if(length(grep("\\end{table}", x, fixed = TRUE)) >0){
        envir = "table"
        remove_envir = TRUE
    } else if(length(grep("\\end{longtable}", x, fixed = TRUE)) >0){
        envir = "longtable"
        remove_envir = FALSE
    } 
    x <- add_footnote_perso(x, options = options, envir = envir,
                            remove_envir = remove_envir,
                            stop_centering = stop_centering)
    
    class(x) <- "knitr_kable"
    if(is_latex){
        attr(x, "format") <- "latex"
    }else if(is_html){
        attr(x, "format") <- "html"
    }
    x
}

local({
    # hook_plot2 <- knitr::knit_hooks$get('plot')
    knitr::knit_hooks$set(plot = function(x, options) {
        if(is.null(options$fig.cap))
            return(knitr::hook_plot_md(x, options))
        if(is_latex){
            # res <-  knitr:::hook_plot_tex(x, options)
            options$fig.cap <- markdown_latex(options$fig.cap)
            res <-  knitr:::hook_plot_tex(x, options)
            # res <- md_framed(res, options)
            # res <- add_footnote_latex(res, options)
        }else if(is_html){
            res <- knitr::hook_plot_md(x, options)
            # res <- add_footnote_html(res, options)
        }else{
            res <-  knitr::hook_plot_md(x, options)
        }
        res <- add_footnote_perso(res, options)
        md_framed(res, options)
    })
})
# library(knitr)
# local({
#   hook_plot <- function (x, options) {
#       
#     if (options$fig.show == "animate") 
#         return(hook_plot_html(x, options))
#     base = knitr:::`%n%`(opts_knit$get("base.url"), "")
#     cap = knitr:::.img.cap(options)
#     alt = knitr:::.img.cap(options, alt = TRUE)
#     w = options[["out.width"]]
#     h = options[["out.height"]]
#     s = options$out.extra
#     a = options$fig.align
#     ai = options$fig.show == "asis"
#     lnk = options$fig.link
#     pandoc_html = cap != "" && is_html_output()
#     in_bookdown = isTRUE(opts_knit$get("bookdown.internal.label"))
#     plot1 = ai || options$fig.cur <= 1L
#     plot2 = ai || options$fig.cur == options$fig.num
#     to = pandoc_to()
#     from = pandoc_from()
#     if (is.null(w) && is.null(h) && is.null(s) && is.null(options$fig.alt) && 
#         a == "default" && !(pandoc_html && in_bookdown)) {
#         nocap = cap == "" && !is.null(to) && !grepl("^markdown", 
#             to) && (options$fig.num == 1 || ai) && !grepl("-implicit_figures", 
#             from)
#         res = sprintf("![%s](%s%s)", cap, base, .upload.url(x))
#         if (!is.null(lnk) && !is.na(lnk)) 
#             res = sprintf("[%s](%s)", res, lnk)
#         res = paste0(res, if (nocap) 
#             "<!-- -->"
#         else "", if (is_latex_output()) 
#             " "
#         else "")
#         return(res)
#     }
#     add_link = function(x) {
#         if (is.null(lnk) || is.na(lnk)) 
#             return(x)
#         sprintf("<a href=\"%s\" target=\"_blank\">%s</a>", lnk, 
#             x)
#     }
#     if (pandoc_html && !isTRUE(grepl("-implicit_figures", from))) {
#         d1 = if (plot1) 
#             sprintf("<div class=\"figure\"%s>\n", knitr:::css_text_align(a))
#         d2 = sprintf("<p class=\"caption\">Note: %s</p>", cap)
#         if(!is.null(options$comment)){
#           d2 <- sprintf("<p class='comment'>%s</p>%s",options$comment, d2)
#         }
#         img = sprintf("<img src=\"%s\" alt=\"%s\" %s />", paste0(opts_knit$get("base.url"), 
#             knitr:::.upload.url(x)), alt, knitr:::.img.attr(w, h, s))
#         img = add_link(img)
#         if (isTRUE(options$fig.topcaption)) {
#             paste0(d1, if (ai || options$fig.cur <= 1) 
#                 d2, img, if (plot2) 
#                 "</div>") 
#         }
#         else {
#             paste0(d1, img, if (plot2) 
#                 paste0("\n", d2, "\n</div>"))
#         }
#     }
#     else add_link(.img.tag(.upload.url(x), w, h, alt, c(s, sprintf("style=\"%s\"", 
#         css_align(a)))))
# }
#   knitr::knit_hooks$set(plot = function(x, options) {
#       hook_plot(x, options)
#   })
# })

library(htmltools)
carousel <- function(files, div_id, enableControl = TRUE){
    carousel_file <- function(x, active = FALSE){
        tags$div(class = sprintf("carousel-item%s", ifelse(active, " active", "")),
                 tags$img(class="d-block w-100", src = x)
        )
        
    }
    control <- NULL
    if(enableControl){
        p1 <- withTags({
            a(class ="carousel-control-prev", href = paste0("#", div_id), `data-slide`="prev",
              span(class="carousel-control-prev-icon")
            )})
        p2 <- withTags({
            a(class ="carousel-control-next", href = paste0("#", div_id), `data-slide`="next",
              span(class="carousel-control-next-icon")
            )})
        control <- tagList(p1, p2)
    }
    first_file <- carousel_file(files[[1]], active = TRUE)
    all_files <- c(list(first_file), lapply(files[-1], carousel_file, active = FALSE))
    all_files <- tags$div(class = "carousel-inner",
                          tagList(all_files)
    )
    all_files
    withTags({
        div(class="carousel slide", `data-ride`="carousel", id = div_id,
            all_files,
            control
        )
    })
}
# carousel(div_id = "carouselExampleSlidesOnly",
# files = sprintf("img/kernels/%i.png",2:4))

## Graphiques 3D

library(plot3D)
global_plot <- function(data, q, method, degree, phi = 40,
                        theta = 40,
                        titre = NULL){
    
    data_tri <- data[(data$q %in% as.numeric(q)) &
                         (data$method %in% method) &
                         (data$degree %in% as.numeric(degree)),]
    scatter_3D(data_tri, titre = titre, phi = phi, theta = theta)
}
scatter_3D <- function(x, titre = NULL, phi = 40,
                       theta = 40){
    add <- nrow(x) >0
    if(add){
        with(x, 
             scatter3D(x = fidelity.weight,
                       y = smoothness.weight,
                       z = timeliness.weight,
                       colvar = NULL, 
                       phi = phi, theta = theta,
                       # bty = "g",
                       pch = 1,
                       # cex = 0.1, alpha = 0.4,
                       ticktype = "detailed",
                       xlim = c(0,1),
                       ylim = c(0,1),
                       zlim = c(0,1), 
                       xlab = "\n\nFidelity",
                       ylab ="\n\nSmoothness",
                       zlab = "\n\nTimeliness",
                       main = titre))
        polygon3D(x = c(0,0,1), y = c(0,1,0), z = c(1,0,0),
                  add = add, alpha = 0.2,
                  ticktype = "detailed",
                  phi = phi, theta = theta,
                  xlim = c(0,1),
                  ylim = c(0,1),
                  zlim = c(0,1), 
                  xlab = "\n\nFidelity",
                  ylab ="\n\nSmoothness",
                  zlab = "\n\nTimeliness",
                  main = titre)
    }else{
        scatter3D(x = -2,
                  y = 2,
                  z = 2,
                  colvar = NULL, 
                  phi = phi, theta = theta,
                  # bty = "g",
                  pch = 1,
                  # cex = 0.1, alpha = 0.4,
                  ticktype = "detailed",
                  xlim = c(0,1),
                  ylim = c(0,1),
                  zlim = c(0,1), 
                  xlab = "\n\nFidelity",
                  ylab ="\n\nSmoothness",
                  zlab = "\n\nTimeliness",
                  main = titre)
    }
}

table_tp <- function(x, digits = 2, diff = FALSE, rapport = FALSE, quartile = FALSE){
    x <- do.call(rbind, x)
    if(length(grep("X12|X13|X11", colnames(x)))>0){
        col_names <- c("X13-ARIMA",colnames(x)[-1])
    }else{
        col_names <- colnames(x)
    }
    
    # On enlève les deux dernières colonnes qui contiennent dates + nom série
    x <- x[, c(1,0)-ncol(x)] 
    col_names <- col_names[c(1,0)-length(col_names)] 
    if(diff & !rapport){
        x <- diff_x13(x)
        col_names <- col_names[-1]
    }
    if(!diff & rapport){
        x <- rapport_x13(x)
        col_names <- col_names[-1]
    }
    nb_series = nrow(x)
    if(quartile){
        by <- 0.25
        def_row <- c("Q1", "Méd.", "Q3")
    }else{
        by <- 0.1
        def_row <- c("D1", "D2", "D3", "D4", "Méd.", "D6", "D7",
                     "D8", "D9")
    }
    data_q <- apply(x,2,quantile,seq(0,1, by))
    data_q <- round(rbind(data_q,
                          apply(x, 2, mean)), digits)
    colnames(data_q) <- col_names
    rownames(data_q) <- c("Min", def_row, "Max", "Moy")
    list(n = nb_series, table = data_q)
}

capitalize <- function(x){
    gsub("(^|[[:space:]])([[:alpha:]])", "\\1\\U\\2",    # Uppercase with Base R
         x,
         perl = TRUE)
}
```
# Introduction {-}

L’analyse du cycle économique, et en particulier la détection rapide des points de retournement d'une série, est un sujet de première importance dans l'analyse de la conjoncture économique. 
Pour cela, les indicateurs économiques sont généralement corrigés des variations saisonnières.
Toutefois, afin d'améliorer leur lisibilité, il peut être nécessaire d'effectuer un lissage supplémentaire afin de réduire le bruit, et ainsi analyser la composante tendance-cycle.
Par construction, les méthodes d’extraction de tendance-cycle sont étroitement liées aux méthodes de désaisonnalisation puisqu’elles sont généralement appliquées sur des séries corrigées des variations saisonnières. 

Les moyennes mobiles, ou les filtres linéaires, sont omniprésents dans les méthodes d'extraction du cycle économique et d'ajustement saisonnier^[
Une moyenne mobile est une méthode statistique qui consiste à appliquer une moyenne pondérée glissante à une série temporelle : à chaque date $t$ on calcule une moyenne pondérée de $p$ points passés et $q$ points futurs où $p,q\geq0$ dépend de la moyenne mobile.
]. 
Ainsi, la méthode de désaisonnalisation X-13ARIMA-SEATS utilise des moyennes mobiles de Henderson et des moyennes mobiles composites pour estimer les principales composantes d'une série chronologique. 
Au centre de la série, des filtres symétriques sont appliqués. 
En revanche, en raison du manque d’observations futures, pour estimer les points les plus récents, toutes ces méthodes doivent s'appuyer sur des filtres asymétriques. 
Par exemple, même si X-13ARIMA-SEATS appliquent des moyennes symétriques aux prévisions obtenues à partir d'un modèle ARIMA, cela revient à appliquer des filtres asymétriques en fin de série, car les valeurs prédites sont des combinaisons linéaires de valeurs passées. 

Si ces moyennes mobiles asymétriques ont de bonnes propriétés concernant la taille des révisions futures induites par le processus de lissage^[Voir par exemple @pierce1980SA.], elles induisent également des déphasages qui retardent en général la détection en temps réel des points de retournement.

L'objectif de cette étude est de décrire et de comparer les approches récentes permettant l’extraction de tendance-cycle : filtres polynomiaux locaux, méthodes basées sur une optimisation des propriétés des filtres et filtres basés sur les espaces de Hilbert à noyau reproduisant (RKHS).  
Toutes ces méthodes sont implémentées dans le *package* `r fa_r_project` `rjd3filters`^[https://github.com/palatej/rjd3filters.], tous les résultats de cette étude sont facilement reproductibles.
En raison du lien entre la désaisonnalisation et l'extraction de tendance-cycle (section \@ref(sec-SAtoTCE)), nous nous concentrons sur les méthodes non paramétriques qui peuvent être incluses dans X-13ARIMA-SEATS.
Après une description des propriétés générales d'un filtre linéaire (section \@ref(sec-propMM)), nous décrivons une approche générale qui permet d'englober les différentes méthodes développées par @proietti2008, @GrayThomson1996, @ch15HBSA, @trilemmaWMR2019 et @dagumbianconcini2008 (sections \@ref(sec-formulegen) à \@ref(sec-nonparamreg)) et nous mettrons également en exergue les liens théoriques entre ces différentes variables.
Enfin, dans la section \@ref(sec-comparison), nous comparons les différentes méthodes en termes de déphasage et de révisions, en les appliquant sur des séries simulées et réelles.

    
\newpage




<!--chapter:end:01-intro.Rmd-->


# De la désaisonnalisation à l'estimation tendance-cycle {#sec-SAtoTCE}

Placeholder



<!--chapter:end:02-sa_to_tce.Rmd-->


# Quelques propriétés sur les moyennes mobiles {#sec-propMM}

Placeholder


## Gain et fonction de déphasage
## Propriétés souhaitables d'une moyenne mobile
### Préservation de tendances
### Réduction du bruit
## Estimation en temps réel et moyennes mobiles asymétriques {#sec-mmasym}
### Moyennes mobiles asymétriques et prévision {#subec:mmetprev}
### Indicateurs de qualité des moyennes mobiles asymétriques

<!--chapter:end:03-mm_properties.Rmd-->


# D'une formule générale sur la construction des filtres asymétriques à l'approche FST {#sec-formulegen}

Placeholder


## formule générale de construction des filtres asymétriques {#subsec-formulegen}
## Approche *Fidelity-Smoothness-Timeliness* (FST) {#subsec-GuggemosEtAl}

<!--chapter:end:04-fst.Rmd-->


# Filtres dépendant des données : trilemme ATS {#sec-WildiMcLeroy}

Placeholder



<!--chapter:end:05-wildi.Rmd-->


# Régression non paramétrique et régression polynomiale locale {#sec-nonparamreg}

Placeholder


## Régression polynomiale : approche de Proietti et Luati {#sec-proietti}
### Filtres symétriques
### Les différents noyaux {#sec-kernels}
### Quelques filtres symétriques particuliers {#sec-sympolyfilter}
### Filtres asymétriques {#subsec-lppasymf}
### Paramétrisation locale des filtres asymétriques {#subsec-localic}
## Extension avec le critère de *timeliness* {#subsec-lptimeliness}
## Régression polynomiale : Gray et Thomson {#subsec-graythomson}
### Filtres symétriques
### Filtres asymétriques
## Reproducing Kernel Hilbert Space (RKHS) : approche de Dagum et Bianconcini {#sec-rkhs}
## Liens entre les différentes méthodes {#subsec-equivlpfst}
### Critères de Gray et Thomson et ceux de Grun-Rehomme *et alii*
### Équivalence avec les moindres carrés pondérés
### RKHS et polynômes locaux

<!--chapter:end:06-nonparamreg.Rmd-->


# Comparaison des différentes méthodes {#sec-comparison}

Placeholder


## Méthodologie
## Séries simulées
### Comparaison des filtres polynomiaux locaux et des filtres RKHS
## Série réelle

<!--chapter:end:07-comparaison.Rmd-->


# Conclusion {.unnumbered}

Placeholder



<!--chapter:end:50-conclusion.Rmd-->

```{r include=FALSE, cache=FALSE}
library(kableExtra)
# knitr::knit_hooks$restore() # Pour les réinitialiser

is_html <- knitr::is_html_output()
is_latex <- knitr::is_latex_output()

fig.ext <- ifelse(is_latex,"pdf",ifelse(is_html,"svg", "jpg"))
fig.ext_cube <- ifelse(is_latex,"jpg","jpg")
dev <- ifelse(is_latex,"pdf","svg")
# dev2 <- knitr::opts_chunk$get("dev")
fig.path <- ifelse(is_latex,"pdf",ifelse(is_html,"html", "autres"))
knitr::opts_chunk$set(echo = FALSE,
                      fig.path = sprintf("img/bookdown/%s/", fig.path),
                      fig.ext = fig.ext,
                      dev = dev, dpi = 76,
                      cache = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      fig.align = 'center',
                      fig.pos = "",
                      out.extra = NULL)
height_cube <- 1.7



# Fontawesome
htmltools::tagList(rmarkdown::html_dependency_font_awesome())

if(is_html){
    fa_arrow_circle_right <- '<i class="fas fa-arrow-circle-right"></i>'
    fa_r_project <- '<i class="fab fa-r-project"></i>'
}else {
    if(is_latex){
        fa_arrow_circle_right <- "\\faIcon{arrow-circle-right}"
        fa_r_project <- "\\faIcon{r-project}"
    }else {
        fa_arrow_circle_right <- "->"
        fa_r_project <- 'R'
    }
}

################################
########## KNITR ###############
################################
library(htmltools)
markdown_latex <- function(text, to = "latex"){
    res <- sapply(text, function(x){
        dir = tempdir()
        infile <- tempfile(fileext=".md", tmpdir = dir)
        # writeLines(x, infile)
        writeLines(enc2utf8(x), infile,
                   useBytes=TRUE)
        file.copy("biblio.bib",file.path(dir,"biblio.bib"))
        outfile <- tempfile(fileext=".tex", tmpdir = dir)
        rmarkdown::pandoc_convert(infile,
                                  to = to,
                                  from = "markdown",
                                  citeproc = FALSE,
                                  options = c("--bibliography=biblio.bib",
                                              "--biblatex"
                                              ),
                                  output = outfile,
                                  wd = dir)
        paste(readLines(outfile, encoding="UTF-8"), collapse = " ")
    })
    names(res) <- NULL
    res
}
converttext <- ifelse(is_latex,markdown_latex, \(x) x)
latex_emph <- function(entete = "Note", x, sep = "\n\n"){
    txt <- paste(sprintf("\\emph{%s}", x), collapse = sep)
    if(length(x)>1){
        entete <- paste0(entete,"s")
    }
    sprintf("\n\\emph{%s} : %s", entete, txt)
}
md_framed <- function(x, options){
    if (!is_latex || is.null(options$mdframed) || !options$mdframed || 
        is.null(options$fig.cap))
        return (x)
    # cap <- options$fig.cap
    # label <- fig$label
    # \label{fig:filtersdafcoefs}
    # \includegraphics[width=3cm,height=3cm]{example-image-a}
    #     \captionof{figure}{exampleimg}
    x <- gsub("\\\\begin\\{figure\\}(\\[!?\\w*\\])?",
              "", x)
    x <- gsub("\\caption","\\captiontmp", x, fixed = TRUE)
    # x <- gsub("^(\\n)*", "", x)
    x <- gsub("\n\n{\\centering",
              "\\begin{center}", x, fixed = TRUE)
    x <- sub("} \n\n}","}", x, fixed = TRUE)
    x <- gsub("\\end{figure}",
              "\\end{center}", x, fixed = TRUE)
    x
}

add_fig_opt_html <- function(x, options, nom_opt){
    nom_opt_complet <- sprintf("fig.%s", tolower(nom_opt))
    opt <- options[[nom_opt_complet]]
    if(!is.null(opt)){
        first_txt <- tags$p(opt[1], id = nom_opt, class = "title caption")
        all_txt <- c(list(first_txt),
                     lapply(opt[-1], tags$p, class = "caption"))
        txt <- withTags(
            div(class = "caption", id = nom_opt,
                tagList(all_txt)
            )
        )
        x <- paste(x,
                   as.character(txt),
                   sep = "\n")
    }
    x
}

add_fig_opt_latex <- function(x, options, nom_opt, 
                              prefix = nom_opt,
                              sep_multi = "---", sep_fichier = "\n\n"){
    if(is.null(prefix)){
        prefix <- nom_opt
    }
    if(is.null(sep_multi)){
        sep_multi <- "---"
    }
    if(is.null(sep_fichier)){
        sep_fichier <- "\n\n"
    }
    nom_opt_complet <- sprintf("fig.%s", tolower(nom_opt))
    opt <- options[[nom_opt_complet]]
    if(!is.null(opt)){
        x <- paste(x,
                   latex_emph(prefix,
                              markdown_latex(opt),
                              sep = sep_multi),
                   sep = sep_fichier)
    }
    x
}
cite_ref_latex <- function(x){
    split <- strsplit(x, " ")
    sapply(split, function(phrase){
        id_ref <- grep("@", phrase)
        for(i in id_ref){
            x <- phrase[i]
            suffix = gsub("^@\\w*","",x)
            toremoved <- paste0("@",suffix)
            nomref <- x
            for(i_c in seq_len(nchar(toremoved))){
                nomref <- gsub(substr(toremoved,i_c,i_c),"",
                               nomref, fixed = TRUE) 
            }
            phrase[i] <- sprintf("\\textcite{%s}%s",nomref, suffix)
        }
        paste(phrase, collapse = " ")
    })
}
add_footnote_latex <- function(x, options, envir = "figure", remove_envir = TRUE,
                               stop_centering = FALSE){
    
    fin_envir <- sprintf("\\end{%s}", envir)
    if(length(grep(fin_envir, x, fixed = TRUE)) == 0){
        return(x)
    }
    
    params <- list(Source = list(),
                   Champ = list(),
                   Note = list(sep_multi = "\n\n"),
                   Lecture = list(prefix = "Note de lecture"))
    ajouts <- "\\footnotesize"
    for (opt in names(params)){
        ajouts <- add_fig_opt_latex(ajouts, options, opt,
                                    prefix = params[[opt]]$prefix,
                                    sep_multi = params[[opt]]$sep_multi,
                                    sep_fichier = params[[opt]]$sep_fichier)
    }
    if(stop_centering){
        x <- sub("\\\\centering", "{\n\\\\centering", x)
        x <- paste0(x, "}\n")
    }
    x <- paste0(x, ajouts, "\n\\normalsize")
    if(remove_envir){
        x <- sub(fin_envir, "", x, fixed = TRUE)
        
        x <- paste0(x, fin_envir)  
    }
    x  
}

add_footnote_html <- function(x, options){
    for (opt in c("source", "champ", "note", "lecture")){
        x <- add_fig_opt_html(x, options, opt)
    }
    x
}
add_footnote_perso <- function(x, options, envir = "figure", remove_envir = TRUE,
                               stop_centering = FALSE){
    if(is_latex){
        res <-  add_footnote_latex(x, options, envir = envir,
                                   remove_envir = remove_envir,
                                   stop_centering = stop_centering)
        
    }else if(is_html){
        res <-  add_footnote_html(x, options)
    }else{
        res <-  x
    }
    res
}
add_footnote_kable <- function(x, options = knitr::opts_current$get(),
                               stop_centering = FALSE){
    envir = remove_envir = NULL
    if(length(grep("\\end{table}", x, fixed = TRUE)) >0){
        envir = "table"
        remove_envir = TRUE
    } else if(length(grep("\\end{longtable}", x, fixed = TRUE)) >0){
        envir = "longtable"
        remove_envir = FALSE
    } 
    x <- add_footnote_perso(x, options = options, envir = envir,
                            remove_envir = remove_envir,
                            stop_centering = stop_centering)
    
    class(x) <- "knitr_kable"
    if(is_latex){
        attr(x, "format") <- "latex"
    }else if(is_html){
        attr(x, "format") <- "html"
    }
    x
}

local({
    # hook_plot2 <- knitr::knit_hooks$get('plot')
    knitr::knit_hooks$set(plot = function(x, options) {
        if(is.null(options$fig.cap))
            return(knitr::hook_plot_md(x, options))
        if(is_latex){
            # res <-  knitr:::hook_plot_tex(x, options)
            options$fig.cap <- markdown_latex(options$fig.cap)
            res <-  knitr:::hook_plot_tex(x, options)
            # res <- md_framed(res, options)
            # res <- add_footnote_latex(res, options)
        }else if(is_html){
            res <- knitr::hook_plot_md(x, options)
            # res <- add_footnote_html(res, options)
        }else{
            res <-  knitr::hook_plot_md(x, options)
        }
        res <- add_footnote_perso(res, options)
        md_framed(res, options)
    })
})
# library(knitr)
# local({
#   hook_plot <- function (x, options) {
#       
#     if (options$fig.show == "animate") 
#         return(hook_plot_html(x, options))
#     base = knitr:::`%n%`(opts_knit$get("base.url"), "")
#     cap = knitr:::.img.cap(options)
#     alt = knitr:::.img.cap(options, alt = TRUE)
#     w = options[["out.width"]]
#     h = options[["out.height"]]
#     s = options$out.extra
#     a = options$fig.align
#     ai = options$fig.show == "asis"
#     lnk = options$fig.link
#     pandoc_html = cap != "" && is_html_output()
#     in_bookdown = isTRUE(opts_knit$get("bookdown.internal.label"))
#     plot1 = ai || options$fig.cur <= 1L
#     plot2 = ai || options$fig.cur == options$fig.num
#     to = pandoc_to()
#     from = pandoc_from()
#     if (is.null(w) && is.null(h) && is.null(s) && is.null(options$fig.alt) && 
#         a == "default" && !(pandoc_html && in_bookdown)) {
#         nocap = cap == "" && !is.null(to) && !grepl("^markdown", 
#             to) && (options$fig.num == 1 || ai) && !grepl("-implicit_figures", 
#             from)
#         res = sprintf("![%s](%s%s)", cap, base, .upload.url(x))
#         if (!is.null(lnk) && !is.na(lnk)) 
#             res = sprintf("[%s](%s)", res, lnk)
#         res = paste0(res, if (nocap) 
#             "<!-- -->"
#         else "", if (is_latex_output()) 
#             " "
#         else "")
#         return(res)
#     }
#     add_link = function(x) {
#         if (is.null(lnk) || is.na(lnk)) 
#             return(x)
#         sprintf("<a href=\"%s\" target=\"_blank\">%s</a>", lnk, 
#             x)
#     }
#     if (pandoc_html && !isTRUE(grepl("-implicit_figures", from))) {
#         d1 = if (plot1) 
#             sprintf("<div class=\"figure\"%s>\n", knitr:::css_text_align(a))
#         d2 = sprintf("<p class=\"caption\">Note: %s</p>", cap)
#         if(!is.null(options$comment)){
#           d2 <- sprintf("<p class='comment'>%s</p>%s",options$comment, d2)
#         }
#         img = sprintf("<img src=\"%s\" alt=\"%s\" %s />", paste0(opts_knit$get("base.url"), 
#             knitr:::.upload.url(x)), alt, knitr:::.img.attr(w, h, s))
#         img = add_link(img)
#         if (isTRUE(options$fig.topcaption)) {
#             paste0(d1, if (ai || options$fig.cur <= 1) 
#                 d2, img, if (plot2) 
#                 "</div>") 
#         }
#         else {
#             paste0(d1, img, if (plot2) 
#                 paste0("\n", d2, "\n</div>"))
#         }
#     }
#     else add_link(.img.tag(.upload.url(x), w, h, alt, c(s, sprintf("style=\"%s\"", 
#         css_align(a)))))
# }
#   knitr::knit_hooks$set(plot = function(x, options) {
#       hook_plot(x, options)
#   })
# })

library(htmltools)
carousel <- function(files, div_id, enableControl = TRUE){
    carousel_file <- function(x, active = FALSE){
        tags$div(class = sprintf("carousel-item%s", ifelse(active, " active", "")),
                 tags$img(class="d-block w-100", src = x)
        )
        
    }
    control <- NULL
    if(enableControl){
        p1 <- withTags({
            a(class ="carousel-control-prev", href = paste0("#", div_id), `data-slide`="prev",
              span(class="carousel-control-prev-icon")
            )})
        p2 <- withTags({
            a(class ="carousel-control-next", href = paste0("#", div_id), `data-slide`="next",
              span(class="carousel-control-next-icon")
            )})
        control <- tagList(p1, p2)
    }
    first_file <- carousel_file(files[[1]], active = TRUE)
    all_files <- c(list(first_file), lapply(files[-1], carousel_file, active = FALSE))
    all_files <- tags$div(class = "carousel-inner",
                          tagList(all_files)
    )
    all_files
    withTags({
        div(class="carousel slide", `data-ride`="carousel", id = div_id,
            all_files,
            control
        )
    })
}
# carousel(div_id = "carouselExampleSlidesOnly",
# files = sprintf("img/kernels/%i.png",2:4))

## Graphiques 3D

library(plot3D)
global_plot <- function(data, q, method, degree, phi = 40,
                        theta = 40,
                        titre = NULL){
    
    data_tri <- data[(data$q %in% as.numeric(q)) &
                         (data$method %in% method) &
                         (data$degree %in% as.numeric(degree)),]
    scatter_3D(data_tri, titre = titre, phi = phi, theta = theta)
}
scatter_3D <- function(x, titre = NULL, phi = 40,
                       theta = 40){
    add <- nrow(x) >0
    if(add){
        with(x, 
             scatter3D(x = fidelity.weight,
                       y = smoothness.weight,
                       z = timeliness.weight,
                       colvar = NULL, 
                       phi = phi, theta = theta,
                       # bty = "g",
                       pch = 1,
                       # cex = 0.1, alpha = 0.4,
                       ticktype = "detailed",
                       xlim = c(0,1),
                       ylim = c(0,1),
                       zlim = c(0,1), 
                       xlab = "\n\nFidelity",
                       ylab ="\n\nSmoothness",
                       zlab = "\n\nTimeliness",
                       main = titre))
        polygon3D(x = c(0,0,1), y = c(0,1,0), z = c(1,0,0),
                  add = add, alpha = 0.2,
                  ticktype = "detailed",
                  phi = phi, theta = theta,
                  xlim = c(0,1),
                  ylim = c(0,1),
                  zlim = c(0,1), 
                  xlab = "\n\nFidelity",
                  ylab ="\n\nSmoothness",
                  zlab = "\n\nTimeliness",
                  main = titre)
    }else{
        scatter3D(x = -2,
                  y = 2,
                  z = 2,
                  colvar = NULL, 
                  phi = phi, theta = theta,
                  # bty = "g",
                  pch = 1,
                  # cex = 0.1, alpha = 0.4,
                  ticktype = "detailed",
                  xlim = c(0,1),
                  ylim = c(0,1),
                  zlim = c(0,1), 
                  xlab = "\n\nFidelity",
                  ylab ="\n\nSmoothness",
                  zlab = "\n\nTimeliness",
                  main = titre)
    }
}

table_tp <- function(x, digits = 2, diff = FALSE, rapport = FALSE, quartile = FALSE){
    x <- do.call(rbind, x)
    if(length(grep("X12|X13|X11", colnames(x)))>0){
        col_names <- c("X13-ARIMA",colnames(x)[-1])
    }else{
        col_names <- colnames(x)
    }
    
    # On enlève les deux dernières colonnes qui contiennent dates + nom série
    x <- x[, c(1,0)-ncol(x)] 
    col_names <- col_names[c(1,0)-length(col_names)] 
    if(diff & !rapport){
        x <- diff_x13(x)
        col_names <- col_names[-1]
    }
    if(!diff & rapport){
        x <- rapport_x13(x)
        col_names <- col_names[-1]
    }
    nb_series = nrow(x)
    if(quartile){
        by <- 0.25
        def_row <- c("Q1", "Méd.", "Q3")
    }else{
        by <- 0.1
        def_row <- c("D1", "D2", "D3", "D4", "Méd.", "D6", "D7",
                     "D8", "D9")
    }
    data_q <- apply(x,2,quantile,seq(0,1, by))
    data_q <- round(rbind(data_q,
                          apply(x, 2, mean)), digits)
    colnames(data_q) <- col_names
    rownames(data_q) <- c("Min", def_row, "Max", "Moy")
    list(n = nb_series, table = data_q)
}

capitalize <- function(x){
    gsub("(^|[[:space:]])([[:alpha:]])", "\\1\\U\\2",    # Uppercase with Base R
         x,
         perl = TRUE)
}
```
# (APPENDIX) Annexe {-} 

\newpage
# Synthèse des liens entre les différentes méthodes de construction de moyennes mobiles {#an-diag}

```{r, include=FALSE}
notations <- c("$X = X_d = \\begin{pmatrix} x_0 \\quad\\cdots \\quad x_d \\end{pmatrix}$ avec $x_i'=\\begin{pmatrix} (-h)^i \\quad \\cdots \\quad (h)^i\\end{pmatrix}$.")
notationsasym <- c("$X_d = \\begin{pmatrix} x_0 \\quad\\cdots \\quad x_d \\end{pmatrix}$ avec $x_i'=\\begin{pmatrix} (-h)^i \\quad \\cdots \\quad (q)^i\\end{pmatrix}$ et $X=X_d$ avec $q=h$.")
if(is_latex){
    out.extra='angle=90'
    out.width <- "0.8\\textheight"
}else{
    out.extra <-  NULL
    out.width <- '100%'
}

```

```{r diag-gen-sym, echo=FALSE, engine='tikz', fig.ext=if (is_latex) 'pdf' else 'png', fig.cap="Synthèse des méthodes de construction de moyennes mobiles symétriques $\\theta=(\\theta_{-h},\\dots,\\theta_{h})$ de $2h+1$ termes.", engine.opts = list(template = "img/tikz2pdf.tex"), fig.lecture = notations, out.extra = out.extra, out.width = out.width,fig.pos="!ht"}
\input{diagrams/sym.tex}
```


```{r diag-gen-asym, echo=FALSE, engine='tikz', out.width='90%', fig.ext=if (is_latex) 'pdf' else 'png', fig.cap="Synthèse des méthodes de construction de moyennes mobiles asymétriques $\\theta=(\\theta_{-h},\\dots,\\theta_{q})$, $0\\leq q< h$ avec $\\theta^s$ le filtre symétrique de référence de $2h+1$ termes.", engine.opts = list(template = "img/tikz2pdf.tex"), fig.lecture = notationsasym, out.extra = out.extra, out.width= out.width,fig.pos="!ht"}
\input{diagrams/asym.tex}
```

<!--chapter:end:60-annexe_diag.Rmd-->


# Coefficients, fonctions de gain et de déphasage {#an-graphs}

Placeholder



<!--chapter:end:61-annexe_plot_coefs.Rmd-->


# Équivalence entre l'approche FST et les filtres polynomiaux locaux {#an-equivfstlp}

Placeholder



<!--chapter:end:62-annexe_equiv_lp_fst.Rmd-->

```{r include=FALSE, cache=FALSE}
library(kableExtra)
# knitr::knit_hooks$restore() # Pour les réinitialiser

is_html <- knitr::is_html_output()
is_latex <- knitr::is_latex_output()

fig.ext <- ifelse(is_latex,"pdf",ifelse(is_html,"svg", "jpg"))
fig.ext_cube <- ifelse(is_latex,"jpg","jpg")
dev <- ifelse(is_latex,"pdf","svg")
# dev2 <- knitr::opts_chunk$get("dev")
fig.path <- ifelse(is_latex,"pdf",ifelse(is_html,"html", "autres"))
knitr::opts_chunk$set(echo = FALSE,
                      fig.path = sprintf("img/bookdown/%s/", fig.path),
                      fig.ext = fig.ext,
                      dev = dev, dpi = 76,
                      cache = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      fig.align = 'center',
                      fig.pos = "",
                      out.extra = NULL)
height_cube <- 1.7



# Fontawesome
htmltools::tagList(rmarkdown::html_dependency_font_awesome())

if(is_html){
    fa_arrow_circle_right <- '<i class="fas fa-arrow-circle-right"></i>'
    fa_r_project <- '<i class="fab fa-r-project"></i>'
}else {
    if(is_latex){
        fa_arrow_circle_right <- "\\faIcon{arrow-circle-right}"
        fa_r_project <- "\\faIcon{r-project}"
    }else {
        fa_arrow_circle_right <- "->"
        fa_r_project <- 'R'
    }
}

################################
########## KNITR ###############
################################
library(htmltools)
markdown_latex <- function(text, to = "latex"){
    res <- sapply(text, function(x){
        dir = tempdir()
        infile <- tempfile(fileext=".md", tmpdir = dir)
        # writeLines(x, infile)
        writeLines(enc2utf8(x), infile,
                   useBytes=TRUE)
        file.copy("biblio.bib",file.path(dir,"biblio.bib"))
        outfile <- tempfile(fileext=".tex", tmpdir = dir)
        rmarkdown::pandoc_convert(infile,
                                  to = to,
                                  from = "markdown",
                                  citeproc = FALSE,
                                  options = c("--bibliography=biblio.bib",
                                              "--biblatex"
                                              ),
                                  output = outfile,
                                  wd = dir)
        paste(readLines(outfile, encoding="UTF-8"), collapse = " ")
    })
    names(res) <- NULL
    res
}
converttext <- ifelse(is_latex,markdown_latex, \(x) x)
latex_emph <- function(entete = "Note", x, sep = "\n\n"){
    txt <- paste(sprintf("\\emph{%s}", x), collapse = sep)
    if(length(x)>1){
        entete <- paste0(entete,"s")
    }
    sprintf("\n\\emph{%s} : %s", entete, txt)
}
md_framed <- function(x, options){
    if (!is_latex || is.null(options$mdframed) || !options$mdframed || 
        is.null(options$fig.cap))
        return (x)
    # cap <- options$fig.cap
    # label <- fig$label
    # \label{fig:filtersdafcoefs}
    # \includegraphics[width=3cm,height=3cm]{example-image-a}
    #     \captionof{figure}{exampleimg}
    x <- gsub("\\\\begin\\{figure\\}(\\[!?\\w*\\])?",
              "", x)
    x <- gsub("\\caption","\\captiontmp", x, fixed = TRUE)
    # x <- gsub("^(\\n)*", "", x)
    x <- gsub("\n\n{\\centering",
              "\\begin{center}", x, fixed = TRUE)
    x <- sub("} \n\n}","}", x, fixed = TRUE)
    x <- gsub("\\end{figure}",
              "\\end{center}", x, fixed = TRUE)
    x
}

add_fig_opt_html <- function(x, options, nom_opt){
    nom_opt_complet <- sprintf("fig.%s", tolower(nom_opt))
    opt <- options[[nom_opt_complet]]
    if(!is.null(opt)){
        first_txt <- tags$p(opt[1], id = nom_opt, class = "title caption")
        all_txt <- c(list(first_txt),
                     lapply(opt[-1], tags$p, class = "caption"))
        txt <- withTags(
            div(class = "caption", id = nom_opt,
                tagList(all_txt)
            )
        )
        x <- paste(x,
                   as.character(txt),
                   sep = "\n")
    }
    x
}

add_fig_opt_latex <- function(x, options, nom_opt, 
                              prefix = nom_opt,
                              sep_multi = "---", sep_fichier = "\n\n"){
    if(is.null(prefix)){
        prefix <- nom_opt
    }
    if(is.null(sep_multi)){
        sep_multi <- "---"
    }
    if(is.null(sep_fichier)){
        sep_fichier <- "\n\n"
    }
    nom_opt_complet <- sprintf("fig.%s", tolower(nom_opt))
    opt <- options[[nom_opt_complet]]
    if(!is.null(opt)){
        x <- paste(x,
                   latex_emph(prefix,
                              markdown_latex(opt),
                              sep = sep_multi),
                   sep = sep_fichier)
    }
    x
}
cite_ref_latex <- function(x){
    split <- strsplit(x, " ")
    sapply(split, function(phrase){
        id_ref <- grep("@", phrase)
        for(i in id_ref){
            x <- phrase[i]
            suffix = gsub("^@\\w*","",x)
            toremoved <- paste0("@",suffix)
            nomref <- x
            for(i_c in seq_len(nchar(toremoved))){
                nomref <- gsub(substr(toremoved,i_c,i_c),"",
                               nomref, fixed = TRUE) 
            }
            phrase[i] <- sprintf("\\textcite{%s}%s",nomref, suffix)
        }
        paste(phrase, collapse = " ")
    })
}
add_footnote_latex <- function(x, options, envir = "figure", remove_envir = TRUE,
                               stop_centering = FALSE){
    
    fin_envir <- sprintf("\\end{%s}", envir)
    if(length(grep(fin_envir, x, fixed = TRUE)) == 0){
        return(x)
    }
    
    params <- list(Source = list(),
                   Champ = list(),
                   Note = list(sep_multi = "\n\n"),
                   Lecture = list(prefix = "Note de lecture"))
    ajouts <- "\\footnotesize"
    for (opt in names(params)){
        ajouts <- add_fig_opt_latex(ajouts, options, opt,
                                    prefix = params[[opt]]$prefix,
                                    sep_multi = params[[opt]]$sep_multi,
                                    sep_fichier = params[[opt]]$sep_fichier)
    }
    if(stop_centering){
        x <- sub("\\\\centering", "{\n\\\\centering", x)
        x <- paste0(x, "}\n")
    }
    x <- paste0(x, ajouts, "\n\\normalsize")
    if(remove_envir){
        x <- sub(fin_envir, "", x, fixed = TRUE)
        
        x <- paste0(x, fin_envir)  
    }
    x  
}

add_footnote_html <- function(x, options){
    for (opt in c("source", "champ", "note", "lecture")){
        x <- add_fig_opt_html(x, options, opt)
    }
    x
}
add_footnote_perso <- function(x, options, envir = "figure", remove_envir = TRUE,
                               stop_centering = FALSE){
    if(is_latex){
        res <-  add_footnote_latex(x, options, envir = envir,
                                   remove_envir = remove_envir,
                                   stop_centering = stop_centering)
        
    }else if(is_html){
        res <-  add_footnote_html(x, options)
    }else{
        res <-  x
    }
    res
}
add_footnote_kable <- function(x, options = knitr::opts_current$get(),
                               stop_centering = FALSE){
    envir = remove_envir = NULL
    if(length(grep("\\end{table}", x, fixed = TRUE)) >0){
        envir = "table"
        remove_envir = TRUE
    } else if(length(grep("\\end{longtable}", x, fixed = TRUE)) >0){
        envir = "longtable"
        remove_envir = FALSE
    } 
    x <- add_footnote_perso(x, options = options, envir = envir,
                            remove_envir = remove_envir,
                            stop_centering = stop_centering)
    
    class(x) <- "knitr_kable"
    if(is_latex){
        attr(x, "format") <- "latex"
    }else if(is_html){
        attr(x, "format") <- "html"
    }
    x
}

local({
    # hook_plot2 <- knitr::knit_hooks$get('plot')
    knitr::knit_hooks$set(plot = function(x, options) {
        if(is.null(options$fig.cap))
            return(knitr::hook_plot_md(x, options))
        if(is_latex){
            # res <-  knitr:::hook_plot_tex(x, options)
            options$fig.cap <- markdown_latex(options$fig.cap)
            res <-  knitr:::hook_plot_tex(x, options)
            # res <- md_framed(res, options)
            # res <- add_footnote_latex(res, options)
        }else if(is_html){
            res <- knitr::hook_plot_md(x, options)
            # res <- add_footnote_html(res, options)
        }else{
            res <-  knitr::hook_plot_md(x, options)
        }
        res <- add_footnote_perso(res, options)
        md_framed(res, options)
    })
})
# library(knitr)
# local({
#   hook_plot <- function (x, options) {
#       
#     if (options$fig.show == "animate") 
#         return(hook_plot_html(x, options))
#     base = knitr:::`%n%`(opts_knit$get("base.url"), "")
#     cap = knitr:::.img.cap(options)
#     alt = knitr:::.img.cap(options, alt = TRUE)
#     w = options[["out.width"]]
#     h = options[["out.height"]]
#     s = options$out.extra
#     a = options$fig.align
#     ai = options$fig.show == "asis"
#     lnk = options$fig.link
#     pandoc_html = cap != "" && is_html_output()
#     in_bookdown = isTRUE(opts_knit$get("bookdown.internal.label"))
#     plot1 = ai || options$fig.cur <= 1L
#     plot2 = ai || options$fig.cur == options$fig.num
#     to = pandoc_to()
#     from = pandoc_from()
#     if (is.null(w) && is.null(h) && is.null(s) && is.null(options$fig.alt) && 
#         a == "default" && !(pandoc_html && in_bookdown)) {
#         nocap = cap == "" && !is.null(to) && !grepl("^markdown", 
#             to) && (options$fig.num == 1 || ai) && !grepl("-implicit_figures", 
#             from)
#         res = sprintf("![%s](%s%s)", cap, base, .upload.url(x))
#         if (!is.null(lnk) && !is.na(lnk)) 
#             res = sprintf("[%s](%s)", res, lnk)
#         res = paste0(res, if (nocap) 
#             "<!-- -->"
#         else "", if (is_latex_output()) 
#             " "
#         else "")
#         return(res)
#     }
#     add_link = function(x) {
#         if (is.null(lnk) || is.na(lnk)) 
#             return(x)
#         sprintf("<a href=\"%s\" target=\"_blank\">%s</a>", lnk, 
#             x)
#     }
#     if (pandoc_html && !isTRUE(grepl("-implicit_figures", from))) {
#         d1 = if (plot1) 
#             sprintf("<div class=\"figure\"%s>\n", knitr:::css_text_align(a))
#         d2 = sprintf("<p class=\"caption\">Note: %s</p>", cap)
#         if(!is.null(options$comment)){
#           d2 <- sprintf("<p class='comment'>%s</p>%s",options$comment, d2)
#         }
#         img = sprintf("<img src=\"%s\" alt=\"%s\" %s />", paste0(opts_knit$get("base.url"), 
#             knitr:::.upload.url(x)), alt, knitr:::.img.attr(w, h, s))
#         img = add_link(img)
#         if (isTRUE(options$fig.topcaption)) {
#             paste0(d1, if (ai || options$fig.cur <= 1) 
#                 d2, img, if (plot2) 
#                 "</div>") 
#         }
#         else {
#             paste0(d1, img, if (plot2) 
#                 paste0("\n", d2, "\n</div>"))
#         }
#     }
#     else add_link(.img.tag(.upload.url(x), w, h, alt, c(s, sprintf("style=\"%s\"", 
#         css_align(a)))))
# }
#   knitr::knit_hooks$set(plot = function(x, options) {
#       hook_plot(x, options)
#   })
# })

library(htmltools)
carousel <- function(files, div_id, enableControl = TRUE){
    carousel_file <- function(x, active = FALSE){
        tags$div(class = sprintf("carousel-item%s", ifelse(active, " active", "")),
                 tags$img(class="d-block w-100", src = x)
        )
        
    }
    control <- NULL
    if(enableControl){
        p1 <- withTags({
            a(class ="carousel-control-prev", href = paste0("#", div_id), `data-slide`="prev",
              span(class="carousel-control-prev-icon")
            )})
        p2 <- withTags({
            a(class ="carousel-control-next", href = paste0("#", div_id), `data-slide`="next",
              span(class="carousel-control-next-icon")
            )})
        control <- tagList(p1, p2)
    }
    first_file <- carousel_file(files[[1]], active = TRUE)
    all_files <- c(list(first_file), lapply(files[-1], carousel_file, active = FALSE))
    all_files <- tags$div(class = "carousel-inner",
                          tagList(all_files)
    )
    all_files
    withTags({
        div(class="carousel slide", `data-ride`="carousel", id = div_id,
            all_files,
            control
        )
    })
}
# carousel(div_id = "carouselExampleSlidesOnly",
# files = sprintf("img/kernels/%i.png",2:4))

## Graphiques 3D

library(plot3D)
global_plot <- function(data, q, method, degree, phi = 40,
                        theta = 40,
                        titre = NULL){
    
    data_tri <- data[(data$q %in% as.numeric(q)) &
                         (data$method %in% method) &
                         (data$degree %in% as.numeric(degree)),]
    scatter_3D(data_tri, titre = titre, phi = phi, theta = theta)
}
scatter_3D <- function(x, titre = NULL, phi = 40,
                       theta = 40){
    add <- nrow(x) >0
    if(add){
        with(x, 
             scatter3D(x = fidelity.weight,
                       y = smoothness.weight,
                       z = timeliness.weight,
                       colvar = NULL, 
                       phi = phi, theta = theta,
                       # bty = "g",
                       pch = 1,
                       # cex = 0.1, alpha = 0.4,
                       ticktype = "detailed",
                       xlim = c(0,1),
                       ylim = c(0,1),
                       zlim = c(0,1), 
                       xlab = "\n\nFidelity",
                       ylab ="\n\nSmoothness",
                       zlab = "\n\nTimeliness",
                       main = titre))
        polygon3D(x = c(0,0,1), y = c(0,1,0), z = c(1,0,0),
                  add = add, alpha = 0.2,
                  ticktype = "detailed",
                  phi = phi, theta = theta,
                  xlim = c(0,1),
                  ylim = c(0,1),
                  zlim = c(0,1), 
                  xlab = "\n\nFidelity",
                  ylab ="\n\nSmoothness",
                  zlab = "\n\nTimeliness",
                  main = titre)
    }else{
        scatter3D(x = -2,
                  y = 2,
                  z = 2,
                  colvar = NULL, 
                  phi = phi, theta = theta,
                  # bty = "g",
                  pch = 1,
                  # cex = 0.1, alpha = 0.4,
                  ticktype = "detailed",
                  xlim = c(0,1),
                  ylim = c(0,1),
                  zlim = c(0,1), 
                  xlab = "\n\nFidelity",
                  ylab ="\n\nSmoothness",
                  zlab = "\n\nTimeliness",
                  main = titre)
    }
}

table_tp <- function(x, digits = 2, diff = FALSE, rapport = FALSE, quartile = FALSE){
    x <- do.call(rbind, x)
    if(length(grep("X12|X13|X11", colnames(x)))>0){
        col_names <- c("X13-ARIMA",colnames(x)[-1])
    }else{
        col_names <- colnames(x)
    }
    
    # On enlève les deux dernières colonnes qui contiennent dates + nom série
    x <- x[, c(1,0)-ncol(x)] 
    col_names <- col_names[c(1,0)-length(col_names)] 
    if(diff & !rapport){
        x <- diff_x13(x)
        col_names <- col_names[-1]
    }
    if(!diff & rapport){
        x <- rapport_x13(x)
        col_names <- col_names[-1]
    }
    nb_series = nrow(x)
    if(quartile){
        by <- 0.25
        def_row <- c("Q1", "Méd.", "Q3")
    }else{
        by <- 0.1
        def_row <- c("D1", "D2", "D3", "D4", "Méd.", "D6", "D7",
                     "D8", "D9")
    }
    data_q <- apply(x,2,quantile,seq(0,1, by))
    data_q <- round(rbind(data_q,
                          apply(x, 2, mean)), digits)
    colnames(data_q) <- col_names
    rownames(data_q) <- c("Min", def_row, "Max", "Moy")
    list(n = nb_series, table = data_q)
}

capitalize <- function(x){
    gsub("(^|[[:space:]])([[:alpha:]])", "\\1\\U\\2",    # Uppercase with Base R
         x,
         perl = TRUE)
}
```
\newpage

`r if (knitr::is_html_output()) '
# Références {-}
'`

<!--chapter:end:99-references.Rmd-->

